# 类型、操作符号和表达式

变量和常量，是程序中的基础数据对象。声明，列出将要用到的变量，说明变量的状态，以及初始值。操作符，决定对变量和常量的操作。表达式，利用变量和常量生成新值。对象的类型决定了其值的可能性，以及可接受的操作。

## 变量名

变量名可由数字、字母和`_`组成。第一个字母必须是字母或`_`，标准库一般使用使用`_`作为第一个字母，所以尽量不要作为自命名变量第一个字母。变量名区分大小写。

## 数据类型和大小

1 Byte = 8 Bits

1 KB = 1024 Bytes

1 MB = 1024 KB

1 GB = 1024 MB

基础类型：

- `char`：字符。一个字节（8bit）。
- `short`：短整型。2个字节（本机）。
- `int`：整型。4个字节（本机）。
- `float`：浮点型。4个字节（本机）。
- `double`：双精度浮点型。8个字节（本机）。

可用`short`和`long`修饰`int`类型：`short int`，`long int`。此处的`int`可省略。他们所占内存的大小关系是： `long` >= `int` >=`short`，具体取值范围由系统决定。本机上的大小为16Short, 32Int, 64Long。

可使用`singed`和`unsigned`修饰`char`或整型（int short long）。以char为例，一个字符占8bit，如果为signed，其取值范围为-128 - 127；如果为unsigned，取值范围则为0 - 255。字符默认是signed，还是unsigned，由系统决定，但可打印字符都是正数。

可使用`long`修饰`double`类型，所占内存大小由系统决定，原则为`long double` >= `double` >= `float`。本机上的大小为32Float、64Double、128Double_Float。

limits.h和float.h标准库中定义了这些类型取值范围的符号常量。

- [ex2-1](ex/2-1.c)：编写程序打印有符号signed和无符号unsigned的char、short、int和long类型的取值范围。先使用标准库，再手动计算。计算不同浮点型数据的取值范围？？

## 常量

**整型常量（如1）的默认类型为int。** 如需指定类型，可添加后缀，l或L表示long，u或L表示unsigned，ul或UL表示unsigned long，如123l。

**浮点型常量（如123.4或1e-2）的默认类型为double。** 如需指定类型，可添加后缀，f或F表示float，如1.23f；l或L表示long double，如1.23l。

整数常量可用8进制和16进制表示。前置0表示8进制，前置0x或0X表示16进制，如31用8进制表示为037，用16进制表示为0x1F或0x1f。8进制和16进制常量后也可跟U和L，分别表示unsiged和long型。

**字符常量** 写在单引号内，如`'a'`。其实质是代表ASCII码数字常量，如`0`的ASCII的值为48。在程序中用字符常量，而非其数值表示，通常是为了易读，`0`和0完全没关系。空字符`\0`的数值为0。字符常量参与数学运算的方式与整数完全相同，不过通常用来与其它字符常量做比较。

特殊的转义字符使用转义方式书写，如`\n`（换行字符）。任意的整数都可用字符常量表示，如

- `'\0oo'`，其中oo取值范围为0...7。
- `'\xhh'`，其中hh的取值为（0...9, a...f, A...F）。

```c
#define VTAB '\013' /*垂直制表符*/
#define BELL '\007' /*响铃字符*/

/*对应的16进制表示为：*/

#define VTAB '\xb' /*垂直制表符*/
#define BELL '\x7' /*响铃字符*/
```

完整的转义字符表：

字符     | 含义        | 字符     | 含义
:----- | :-------- | :----- | :----
`\a`   | 响铃字符      | `\b`   | 后退字符
`\f`   | formfeed? | `\n`   | 换行字符
`\r`   | 回车字符      | `\t`   | 水平制表符
`\v`   | 垂直制表符     | `\\`   | 反斜线
`\?`   | 问号        | `\'`   | 单引号
`\"`   | 双引号       | `\0oo` | 8进制数字
`\xhh` | 16进制数字    |

**常量表达** 为仅衍生出常量的表达式。其值在编译时计算，而不是在运行时计算。如：

```c
#define MAXLINE 1000
char line[MAXLINE + 1]
// 或
#define LEAP 1 /* 此年是否闰年 */
int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
```

**字符串常量** 由0个或多个字符组成，被双引号包裹。如`"this is a string"`。双引号并不是字符串常量的一部分，只是起分割作用，使用转义字符的方式与转义字符相同。字符串常量可在编译时合并，如：

```c
"hello, " "world"
```

此特点可用来将过长的字符分行写，或写在不同源文件中？。

实际上，字符串常量是字符数组。计算机内部，字符串常量所代表的字符数组最后一个元素是`\0`。所以，所占内存大小还要加上一个`\0`字符的大小。可以得出，字符串长度没有限制，要得出一个字符串的长度，需将其整个扫描一遍。如下面定义的strlen(s)函数：

```c
/*计算字符串长度*/
int strlen(char s[]){
    int i = 0;
    while(s[i]!='\0'){
        i++;
    }
    return i;
}
```

strlen及其其它字符串操作函数都定义在标准库string.h中。

**枚举常量** 包含一组整数常量。默认第一个元素值为0，依次递增1，如`enum boolean{NO, YES}`中，NO为0，YES为1。如果其中一个元素指定值，紧随的元素值依次递增1。如：

```c
enum escapes {
    BELL='\a', BACKSPACE='\b', TAB='\t',NEWLINE='\n', VTAB='\v', RETURN='\r'
};

enum months {
    JAN=1,FEB,MAR,APR, MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC
};
/*FEB=2, MAR=3,....*/
```

不同枚举型中的元素名需不同，同一个枚举型中的元素值可重复。

较`#define`而言，声明常量时，枚举型更方便。不过，编译器并不检测枚举型中的元素值是否合法。然而，在错误检测方面枚举型还是更胜一筹。

## 声明

变量使用前必须声明，以确定类型，分配内存。同类型变量的声明可写在一行内：

```c
int lower, upper, step;
```

不过每个变量单行声明可方便注释：

```c
int lower; /*最低值*/
int upper; /*最高值*/
int step; /*梯度*/
```

变量声明时可初始化：

```c
int lower = 0;
int upper = 300;
int step = 20;
```

变量声明时如果不初始化，外部变量和静态变量默认值为0，自动变量不定。

可使用`const`关键字声明值不会改变的变量：

```c
const int step = 20;
```

也可用`const`关键字声明作为函数参数的数组：

```c
int strlen(const char[]);
```

## 数学运算

数学运算使用的操作符有`+`、`-`、`*`、`/`和`%`。整数间进行除法运算时，小数部分会被"抹去"。

求模运算的规则为（以`x%y`为例）：如果x能被y整除，结果为0，否则为`x/y`的余数。不接受float的double类型的求模运算。如果x或y为负数，结果的正负性由系统决定。下面为利用`%`操作符判断是否闰年的表达式：

```c
int is_leap = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
```

## 关系和逻辑运算符

关系运算符有：`>`、`>=`、`<`、`<=`、`==`和`!=`。

逻辑运算符有：`||`和`&&`。结果为真（1）或假（0）。

同其它语言中的逻辑运算符一样，C语言中的逻辑运算符也是能判断表达式的结果时，就不计算后面的子表达式。如前面的get_line函数的for循环条件判断，只要`i < lim - 1`不成立，结果就为假（0），循环结束：

```c
for (i = 0; i < lim - 1 && (c = getchar() != EOF) && c != '\n'; i++) {
    line[i] = c;
}
```

- [ex2-2](ex/2-2.c)：重写上面的for循环，不使用逻辑操作符`&&`和`||`。

## 类型转换

当参与计算的表达式类型不一样时，仅当将"窄类型"转换为"宽类型"时无信息丢失，会自动转换，如`float + int`的结果为为float；不允许无意义的类型转换，如使用float作为数组下标；丢失信息的表达式，如`short = long`或`int = float`，不会自动转换，也并非非法（有警告提醒），仅会丢失信息。

char类型仅是占内存很小的数字，可自由应用到数学表达式中。利用此特点可灵活处理字符处理，如下面简化版的`atoi`函数（将字符串转换为数字）：

```c
int atoi(char line[]) {
  int i, n, c;
  for (i = 0, n = 0; c = line[i], c >= '0' && c <= '9'; i++) {
    n = 10 * n + (c - '0');
  }
  return n;
}
```

其中的`c - '0'`就利用了字符型的类型转换。下面一例也利用此特点将大写字母转换为小写字母：

```c
int lower(int c) {
  if (c >= 'A' && c <= 'Z') {
    return c + ('a' - 'A');
  } else {
    return c;
  }
}
```

标准库ctype.h中包含了字符处理和函数，如tolower（同此处的lower）函数，和判断是否为数字字符的函数isdigit。

**signed类型转换的基本规则为，将"窄类型"转换为"宽类型"再计算：**

- 如果其中一个数为long double,另一个数转换为long double
- 否则，如果其中一个为double，另一个也转换为double
- 否则，如果一个为float，另一个也转换为float
- 否则，将char和short转换为int
- 如果一个为long，另一个也转换为long。

注意：float类型并不自动转换为double，以减小大型数组的内存占用，以及减少CPU计算时间（double计算相当耗时）。标准库math.h中的所有函数的参数和返回值都使用double类型。

unsigned类型转换较复杂。假设int为16bit，long为32bit。-1L < 1U，因为计算前1U转换为signed long；但是-1L > 1UL，因为计算前-1L转换为unsigned long。

变量赋值时，也发生类型转换，右值转换为变量的数据类型，赋值表达式的结果也是左边变量类型。

传递函数参数时可能发生类型转换。在没有函数原型声明时，char和short自动转换为int，float自动转换为double。这也是声明函数时，实际操作的是char和float，参数类型也声明为int和double。

类型可强制转换，格式为`(类型) 表达式`。比如使用math.h中的sqrt(double)函数，当参数不为double类型时，不能正常计算，所以如果求整型n的平方根，应该为`sqrt((double) n)`。

不过，如果有函数原型声明，参数自动转换：

```c
double sqrt(double);
root = sqrt(2); /*整型2自动转换为double 2*/
```

标准库stdlib.h中，生成随机整数的例子就利用了类型强制转换的特点：

```c
unsigned long int next = 1;
/* rand: 返回随机整数 */
int rand(void) {
  next = next * 1103515245 + 12345;
  return (unsigned int)(next / 65536) % 32768;
}
/* srand: 为rand()设置新的“种子（seed）” */
void srand(unsigned int seed) { next = seed; }
```

- [ex2-3](ex/2-3.c)： 定义htoi(s)函数，将16进制字符串（以0x或0X开始）转换为整数。

## 自增和自减操作符

自增和自减操作符与其它语言相同，即前置为先自增/自减再使用，后置为先使用再自增/自减。

当只需自增/自减时，前置和后置无区别，但当利用自增/自减结果计算时需注意。如下例去除字符串中指定字符的程序：

```c
void squeeze(char str[], int c) {
  int i, j;
  for (i = 0, j = 0; str[i] != '\0'; i++) {
    if (str[i] != c) {
      str[j++] = str[i];
    }
  }
  str[j] = '\0';
}
```

以及简化版的strcat函数（标准库中的strcat函数返回指向第一个参数的指针）。

```c
/*假设s1足够长，能够容下s2*/
void strcat(char s1[], char s2[]) {
  int i, j;
  i = j = 0;
  /*找到s1的终点*/
  while (s1[i] != '\0') {
    i++;
  }
  /*从s1的终点开始接入s2*/
  while ((s1[i++] = s2[j++]) != '\0')
    ;
}
```

- [ex2-4](ex/2-4.c)：定义函数squeeze(s1, s2)，将字符串s2中有s1中的任何字符都删除。

- [ex2-5](ex/2-5.c)：定义函数any(s1,s2)，返回s1中出现s2中任意字符的位置，如果没有，返回-1。（标准库string.h中的strpbrk函数就是此功能，不过返回的是该位置的指针）。

## 位操作符

位运算符只能用于操作整数，即char、short、int和long类型，signed和unsigned均可。位操作符有：

操作符 | 含义
:-- | :--
&   | AND
单竖线 | OR
^   | XOR
~   | NOT
<<  | 左移
>>  | 右移

`&`通常用来掩码，如掩盖掉整数n7位之前的位都变为0：`n = n & 0177`。

`|`通常用来打开位，如打开x上对应SET_ON打开的位：`x = x | SET_ON`。

`^`，两个整数对应位上，只有一个为1，一个为0时，返回值对应位才为1，否则为0。

`<<`，将所有位左移，移空的位用0填补。如`x << 2`，相当于x乘以2的平方。

`>>`，将所有位右移。操作unsigned类型时，左边移空的位用0填补；操作signed类型时，移空的部分一般情况下也是用0填补，不过有些系统有差异？？？。

`～`，将每位置反，即0变成1,1变成0。

如下函数getbits(x,p,n)，截取整数x从位置p开始的n个位，假定位串从右起的索引为0，n和p为在此函数中有意义的正整数。

```c
unsigned getbits(unsigned x, int p, int n) {
  return (x >> (p + 1 - n)) & ~(~0 << n);
}
```

`x >> (p + 1 - n)`将需要的位移到最右端，`~(~0 << n)`使用最右端需要的位都为1，往左都为0。

- [ex2-6](ex/2-6.c)：定义函数setbits(x,p,n,y)，将x上从位置p开始向右的n位，设置称y上的右n位，其它位不变，并且返回x。其它位不变。

- [ex2-7](ex/2-7.c)：定义invert(x,p,n)函数，将x上从位置p开始向右的n位置反（1变为0,0变为1），并且返回x。其它位不变。

- [ex2-8](ex/2-8.c)：定义函数rightrot(x,n)函数，将x上右边n位反转，并返回x。其它位不变。

## 赋值操作符和表达式

与其它语言一样，赋值表达式可简写：`i = i + 2` -> `i += 2`。与其他语言不同的是，此缩写形式可使编译器生成速度更改的执行程序。

以计算整数含位值为1的个数的bitcount函数为例，演示赋值表达式简写：

```c
int bitcount(unsigned int x) {
  int b;
  for (b = 0; x != 0; x >>= 1) {
    if (x & 01) {
      b++;
    }
  }
  return b;
}
```

将参数x声明为unsigned是为了使位右移后，左边的移空位用0填补，而非符号位？，提高函数兼容性。

赋值表达式的结果类型为左操作数的类型，结果为赋值后的结果，如`(c = getchar()) != EOF`。

- [ex2-9](ex/2-9.c)：在（two's complement）数字系统中，`x &= (x - 1)`可去除最右端为1的位。解释原因，并利用此特点重写bitcount函数，使其速度更快。

## 条件表达式

条件表达式的解构为：exp1 ? exp2 : exp3。类型转换也遵循上述规则，假设n为int，f为float，不管n是否大于0，下面表达式的结果类型都为float：

```c
(n > 0) ? f : n;
```

条件表达式可使代码更精简，不过提高了阅读难度，如下2例：

```c
/*打印数组，每行10列*/
for (i = 0; i < n; i++) {
    printf("%6d%c", nums[i], (i % 10 == 9 || i == n - 1) ? '\n' : ' ');
}

/*显示名词单复数*/
printf("You have %d item%s.\n", n, n <= 1 ? "" : "s");
```

- [ex2-10](ex/2-10.c)：重写lower函数，用条件表达式替代if-else语句。

## 操作符优先级

不同的系统架构，对同级运算符运算符的计算顺序不同，如`x = f() + g()`，可以是先计算f函数，也可以是先计算g函数；函数参数的计算顺序也不一定，如`printf("%d %d\n", ++n, power(2, n));`，n++可能先计算，也可能后计算，不可依赖其结果；再如`a[i] = i++;`，不能确定下标为计算后的结果，还是原来的值。

所以，不要依赖特定系统架构的计算顺序。
