# 位操作

<http://www.codeproject.com/Articles/544990/Understand-how-bitwise-operators-work-Csharp-and-V>

## 二进制与十进制的换算

### 十进制转二进制

十进制转二进制的方法为，将整数除以2，一直除到0为止，再将前面的余数（1或0）连起来颠倒即可。以783为例：

将负数转换为二进制数的步骤为（以-783为例）：

1.  取其绝对值转换为二进制数：0000001100001111
2.  每位取相反数：1111110011110000
3.  加上1：1111110011110001

如何确定二进制数的正负： **取决于数字类型**。如果是没有用unsinged声明的16位整数（Int16），则二进制数第一位为0，则为正数；第一位为1，则为负数，所以1111110011110001就是-783。如果是用unsigned声明的16位正数（UInt16）,由于二进制数第一位不表示数值正负，所以可确定1111110011110001为64752。

### 二进制转十进制

从二进制数的最右一位开始，数值（1或0）逐个与2的n（0,1,2....）次方相乘，再相加。

将负数的二进制数转换为十进制数的方法为（以1111111111010011 ，即为例）：

1.  每位取反：1111111111010011  -> 0000000000101100
2.  按上面的方法转换为十进制：44
3.  加1:45
4.  再取相反数：-45
5.  所以1111111111010011表示的十进制数就是-45

## OR `|`

两个二进制数的对应位置上，如果两个数中只要有一个数为1，则结果为1。

以`38|53`为例，两个数对应的二进制数分别为00100110和00110101，运算结果为00110111，在换算称十进制数，结果为55。

## AND `&`

两个二进制数的对应位置上，只有两个数都是1，结果才是1，否则为0。

以`38&53`为例，两个数对应的二进制数分别为00100110和00110101，运算结果为00100100，在换算称十进制数，结果为36。

只有两个数同为负数时，结果才为负数，否则为正数。

## XOR `^`

两个二进制数的对应位置上，只有一个为1，且另一个为0，结果才为1，否则为1。

以`38^53`为例，两个数对应的二进制数分别为00100110和00110101，运算结果为00010011，在换算称十进制数，结果为19。

使用`^`运算符，不需中间变量，就可可实现两个正数间值的互换：

```c
#include <stdio.h>
int main() {
  int m = 11;
  int n = 22;
  printf("m=%d, n=%d\n", m, n);
  m ^= n;
  n ^= m;
  m ^= n;
  printf("m=%d, n=%d\n", m, n);
}
```

`^`运算符号还可用于加密和解密，依赖的原理为，一个数与同一个数两次求`^`后，得到该数本身：

```c
#include <stdio.h>
int main() {
  char msg[] = "abcdefg";
  int count = 7;
  char key = '$';
  int i;
  // 加密
  for (i = 0; i < count; i++) {
    msg[i] ^= key;
  }
  printf("%s\n", msg);
  // 解密
  for (i = 0; i < count; i++) {
    msg[i] ^= key;
  }
  printf("%s\n", msg);
}
```

也可不使用一个字符作为“key”：

```c
#include <stdio.h>
int main() {
  char msg[] = "abcdefg";
  int count = 7;
  char key[] = "claudio";
  int key_count = 7;
  int i;
  // 加密
  for (i = 0; i < count; i++) {
    msg[i] ^= key[i % key_count];
  }
  printf("%s\n", msg);
  // 解密
  for (i = 0; i < count; i++) {
    msg[i] ^= key[i % key_count];
  }
  printf("%s\n", msg);
}
```

## NOT `～`

`～`将二进制数上的每位取反，即1变成0,0变成1。自然，如果原数是正数，结果为负数；原素是负数，结果为正数。不过，如果如果原素为unsigned，结果还是正数？。

## 左位移 `<<`

`<<`将二进制数上的每位向左移动，移空的位置用0填补。其实质相当于将原素乘以2的n（位移数）次方。

如求2的n次方，可使用`1<<n`获得，比math.h标准库中的`pow`函数执行速度快。

## 右位移 `>>`

同左位移相反，即将二进制上的各位向右移动n位，移空的位置用0填补。实质相当于原素除以2的n（位移数）次方。
