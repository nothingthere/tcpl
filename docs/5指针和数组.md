# 指针和数组

指针是一个包含另一个变量地址的变量。指针在C中使用相当频繁，一方面是因为一些运算只能使用指针实现，另一方面是因为使用指针可使代码更精炼，执行速度更快。指针同数组的关系相当密切。

指针一直被诟病如goto语句一样让代码很难阅读。如果使用不当的确如此，比如一不小心就可能创建一个指向错误地址的指针。但是，如果使用恰当，可使代码更简单清晰。

## 指针和地址

计算机内的有一列被标记的连续内存单元，可被单独或以连续组的形式操作。比如，任何一个"位"都可表示char，两个连续的位单元可表示short。

`&`操作符可用于获取对象地址，如果p是指向int型的指针，c为int型，则`p=&c`就可将c的指针赋值给p。`&`操作符只能用于存在于内存中的对象：变量和数组元素；不能用于表达式、常量和寄存器变量。

`*`操作符用于获取指针指向的对象。如果x和y为整型，ip为指向整型的指针，则可进行如下操作：

```c
int x = 1, y = 2, z[10];
int *ip;    /*声明ip为指向整型的指针*/
ip = &x;    /*ip指向x*/
y = *ip;    /*y值为1*/
*ip = 0;    /*x值为0*/
ip = &z[0]; /*ip现在指向z[0]*/
```

由上可见，声明指针的方式为：`int *ip`。可解释为`*ip`的值为int型。

指针也许指向特定类型，不过指向void类型的指针除外，它可指向任意类型。

如果ip指向整型x，则`*ip`可出现在任何x可出现的地方，如`*ip = *ip + 10;`。即将`*ip`的值增加10。

`*`和`&`操作符的紧密程度高于算术计算计算符。`y = *ip + 1`为在ip指向对象的基础上加1，再赋值给y；`*ip += 1`为将ip指向对象的值增加1；`++*ip`和`(*ip)++`都为为ip指向对象增加1，不过后者中的括号不能少。

由于指针本身就是变量，所以可直接操作，如果iq也是指向整型的指针，则`iq=ip`的含义为使iq与ip指向同一地址。

## 指针和函数参数

函数参数采用值传递方式，只能改变实参的副本，如需直接操作实参，就要使用指针。如交换两个整数的值的函数swap(a,b)，下面的写法不能达到目的：

```c
void swap(int x, int y) {
  int tmp;
  tmp = x;
  x = y;
  y = tmp;
}
```

需改写为：

```javascript
void swap(int *px, int *py) {
  int tmp;
  tmp = *px;
  *px = *py;
  *py = tmp;
}
```

调用方式则为`swap(&x, &y);`。

再以读取下一个整数的函数getint为例，此函数需将读取的整数存入目标对象，同时还需利用返回值标记是否读到文件末EOF，或者读取内容无整数。利用此函数读取整数存入数组的用法为：

```c
int n, arr[SIZE], getint(int *);
for(n=0; n < SIZE && getint(&arr[n]) != EOF; n++)
  ;
```

下面为具体实现，如果读到文件末返回EOF，如果不是数值返回0，如果读取成功返回一个正整数：

```javascript
int getint(int *pn) {
  int c;
  int sign;
  // 跳过空格
  while (isspace(c = getch()))
    ;
  // 不是数字，返回
  if (!isdigit(c) && c != '+' && c != '-') {
    ungetch(c);
    return 0;
  }
  // 确定正负号
  sign = c == '-' ? -1 : 1;
  // 跳过正负号
  if (c == '+' || c == '-')
    c = getch();
  // 获取数值
  for (*pn = 0; isdigit(c); c = getch()) {
    *pn = (*pn * 10) + (c - '0');
  }
  *pn *= sign;
  if (c != EOF) {
    ungetch(c);
  }
  // 正常返回
  return c;
}
```

- [ex5-1](ex/5-1.c)：getint函数将后面没跟任何数字的+和-号默认为0，修改函数将+和-字符push回去。
- [ex5-2](ex/5-2.c)：模范getint函数定义getfloat函数。getfloat函数的返回值应该为何种类型。

## 指针和数组

C语言中，指针和数组关系相当深。任何可用数组实现的运算都可用指针实现，而且用指针操作，不过却不易理解。

如定义`int a[10];`,定义了大小为10的数组，即命名为a[0],a[1]...a[9]的连续内存单元。a[i]指数组中的第i个元素。如果pa为指向整型的指针`int *pa`，赋值`pa = &a[0]`就将pa指向了数组a的第一个元素，即pa包含了a[0]的地址。如果有`x = *pa`，则将a[0]的值赋给变量x。

如果pa指向数组的某个元素，则pa+1指向下一个元素，pa+i指向pa后的第i个元素，pa-i指向pa前的第i个元素。

如果pa指向a[0]，则`*(pa+1)`即元素a[1]的值，pa+1为元素a[i]的地址，`*(pa+i)`为元素a[i]的值。

无论数组a中元素的类型为何，pa+1都是指向下一个元素，pa+i都是指向pa后的第i个元素。

数组索引和指针运算非常紧密。 _数组变量或表达式的值，是数组第一个元素的地址。_ 所以`pa=&a[0]`赋值后，pa和a的值完全等价。由于数组名和数组第一个元素的地址等价，所以pa=&a[0]等价于pa=a。

a[i]可写成`*(a+i)`，其实质为当遇见a[i]时，C立即将其转换为`*(a+i)`，这两种写法等价。&a[i]和a+i等价。如果pa是指针，也可将其结合下标使用，如pa[i]等价于`*(pa+i)`。_简单地说，数组下标的写法和指针加减的写法等价。_

**指针和数组名唯一的区别是，指针是变量，如pa=a和pa++的写法合法；而数组名不是变量，a=pa和a++的写法不合法。**

当数组名作为参数传出函数时，实质是传入的首元素地址。函数调用时，其参数都为本地变量，数组名也是如此，仅是指针本地变量。可利用此原理实现另一个版本的strlen函数，计算字符串长度。

```javascript
int strlen(char *s) {
  int n;
  for (n = 0; *s != '\0'; s++)
    n++;
  return n;
}
```

由于s是指针，对起自增合法；strlen函数中的s++对传入其中的参数无影响，只是对strlen的私有指针变量自增，所以下面的调用都合法：

```c
strlen("hello world"); /*字符串常量*/
strlen(array);         /*字符数组*/
strlen(ptr);           /*字符指针*ptr*/
```

`char s[]`和`char *s`在函数定义时作为形参完全等价。后者更准确地指明了该参数为指针。当将数组名作为参数传入函数，函数即可将其视作数组，也可视作指针操作，即使混合使用都可。

也可将数组的一部分传入函数，如果a是一个数组，则`f(&a[2])`和`f(a+2)`都是将a[2]元素的地址传入函数。定义函数时的形参为`f(int arr[]){....}`和`f(int *arr){...}`都可。

如果确定元素存在，即使向后获取数组元素也合法，如p[-1]和p[-2]。不过企图获取数组范围外的元素为非法操作。

## 地址运算

如果p是指向数组中某个元素的指针，则p++使p指向下一个元素，p+=i使p指向当前元素后第i个元素。

将指针、数组和地址运算整合在一起，是C语言的一大优势。下面以编写一个内存分配器程序为例。

此程序需2项功能，alloc(n)返回指向n个连续字符内存的指针，可用于存储字符；；afree(p)，释放p所指向的内存。alloc和afree函数同样也是一个堆实现，"后进先出"。标准库中的malloc和free函数无此限制。

最简单的实现方式为，定义一个足够大allocbuf的缓存区，只对alloc和afree私有，可声明为静态变量。在实际实现中，此数组甚至不需名称？，由malloc分配，或请求系统返回指向未使用的内存单元的指针？。

还需知晓allocbuf已被使用多少。所以需使用一个名为allocp的指针，指向下一个未分配的元素。当alloc请求n可字符空间时，检查allocbuf使用有足够多的剩余。如果有，alloc返回当前的allocp指针，再将allocp增加n，指向下一个未分配元素。如果没有足够剩余，alloc返回0。afree(p)的作用为，当p处于allocbuf内时，将allocp设置为p值。

```javascript
#define ALLOCSIZE 10000 /*最大可用空间*/
static char allocbuf[ALLOCSIZE];
static char *allocp;

char *alloc(int n) {
  if (allocbuf + ALLOCSIZE - allocp >= n) {
    allocp += n;
    return allocp - n;
  } else {
    return 0;
  }
}

void afree(char *p) {
  if (p >= allocbuf && p < allocbuf + ALLOCSIZE) {
    allocp = p;
  }
}
```

指针变量可如普通变量一样初始化，不过只限于0或值为地址的表达式。`static char *allocp = allocbuf`定义allocp为字符指针，初始值为指向allocbuf起始位置，即程序开始执行时的下一个未分配位置。与写法`statuc char *allocp = &allocbuff[0]`等价。

判断语句`if(allocbuf + ALLOCSIZE - allocp >= n){`判断是否有足够空间分配给n个字符。如果有，新的allocp值肯定在allocbuf后。如果满足，返回指向分配字符空间的指针；否则，alloc返回无足够空间的信号。C规定数值0永远不是有效地址，所以返回0作为内存分配失败的信号。

指针和整数数值不可混合计算。只有0除外：常量0可赋给指针，指针可与0比较。stdio.h中符号常量NULL通常用来取代此处的0。

判断语句`if(allocbuf + ALLOCSIZE - allocp >= n){`和`if (p >= allocbuf && p < allocbuf + ALLOCSIZE)`中蕴含了几个指针计算的规则。首先，在特定情况下？，指针可用于比较。如果p和q指向同意数组中的元素，则可使用比较运算符。如`p<q`判p指向的元素是否在q指向的元素前。任何指针可与常量0做`==`或`!=`比较。不指向同意数组元素的指针之间进行数学运算和比较，其结果未定义。（只有一个例外：the address of the first element past the end of an array can be used in pointer arithmetic？）

其次，指针和整数间可进行加减运算。如p+n，其含义为p所指地址元素后第n个元素的地址。无论p指向元素的类型，n会自动计算，依据是p声明时的类型。如果p为int型指针，则每增加1，就会向前推进4位。

指针减法运算同样合法：如果p和q指向同一数组中的元素，且p<q，p-q+1则为p和q中间包含的元素。利用此特点可实现另一版本的strlen函数：

```javascript
int strlen(char *s) {
  char *p = s;
  while (*p != '\0')
    p++;
  return p - s;
}
```

上例中，p初始化为s，即指向参数字符串的第一个字符。在while循环中，历遍每个字符，直到`'\0'`为止。用于p指向字符，p++则使其指向下一个字符，所以p-s为字符串长度。（字符串长度可能超过int型的最大值，可使用stddef.h中的ptrdiff_t类型存储两个指针的差值，ptrdiff_t为带符号类型。如果是不带符号类型，可使用size_t类型，如strlen函数不可能返回负数，所以更适合。sizeof操作符的返回类型也是size_t。）

指针运算具有统一性：如果p指向float类型，则p++则指向下一个float类型。上面的alloc程序如需改变来操作float类型，只需将函数中的char替换成float即可，所有指针操作能都会自动根据数据类型改变。

**合法的指针操作有：同类型指针间相互赋值；指针与整数间加减；指向同一数组元素的指针间相减或比较；指针与常量0比较。** 其他所有指针运算都非法。指针间进行加法，乘法，除法和位运算非法；指针与double和float类型进行加法运算非法；除`void *`外，没有强制类型转换就将一种类型的指着赋值个另一种类型的指针非法。

## 字符指针和函数

如`"I am a string"`这样的字符串常量，实质是字符数组，且以空字符`\0`结尾，方便程序判断字符串终点。所以，一个字符串实际的所占内存是其字符数量的基础上加一。

作为函数实参可能是字符串常量最多的地方，如`printf("hello, world\n");`。实质上是使用的字符指针，printf指示接受了指向字符数组起始位置的指针。即，操作字符串常量，实质是操作指向其第一个字符的指针。

字符串常量也不一定作为函数参数。如果pmessage声明为`char *pmessage`，那么`pmessage = "no is the time";`则将一个字符指针赋值给了pmessage。此处并不是_字符串复制_，仅仅是复制指针。C未提供将整个字符串作为一个单元操作的操作符。

下面的2个定义有明显区别：

```c
char amessage[] = "no is the time"; /*一个数组*/
char *pmessage = "no is the time";  /*一个指针*/
```

amessage是一个数组，足够大以容纳所有字符和一个空字符`\0`，其中的单个字符可能改变，但amessage始终指向同一内存区域；pmessage是一个指针，初始化为指向一个字符串常量，该指针可能指向其他地方，如果试图修改字符串内容，结果未定义？。

下面以实现2个标准库中的函数为例，演示指针和数组的异同。第一个为strcpy(s,t)，将字符串t复制到字符串s中。使用s=t实质是复制指针，要赋值其中的字符，需历遍。

```javascript
void strcpy(char *s, char *t) { /*下标版本*/
  int i;
  i = 0;
  while ((s[i] = t[i]) != '\0')
    i++;
}
```

使用指针实现为：

```javascript
void strcpy(char *s, char *t) { /*指针版本*/
  while ((*s = *t) != '\0') {
    s++;
    t++;
  }
}
```

由于函数参数为值传递，strcpy函数可将s和t作为数组使用，也可作为指针使用。利用指针自增，以及`\0`值为0的特性，老鸟会将上面函数写成这样：

```javascript
void strcpy(char *s, char *t) { /*指针版本*/
  while (*s++ = *t++)
    ;
}
```

另一个例子是strcmp(s,t)函数，比较s和t字符串的大小关系，下标版本为：

```javascript
int strcmp(char *s, char *t) {
  int i;
  for (i = 0; s[i] == t[i]; i++) {
    if (s[i] == '\0')
      return 0;
  }
  return s[i] - t[i];
}
```

指针版本为：

```javascript
int strcmp(char *s, char *t) {
  for (; *s == *t; s++, t++) {
    if (*s == '\0')
      return 0;
  }
  return *s - *t;
}
```

- [ex5-3](ex/5-3.c)：使用指针定义strcat(s,t)函数，将t字符串复制到s末尾。
- [ex5-4](ex/5-4.c)：定义strend(s,t)函数，如果字符串t与s字符串末尾相同，返回1，否则返回0。
- [ex5-5](ex/5-5.c)：定义标准库中的strncpy、strncat和strncmp函数，只操作字符串中最多n个字符，如strncpy(s,t,n)，只从t中复制最多n个字符到s。
- [ex5-6](ex/5-6.c)：使用指针定义前面章节定义过的函数：getline、atoi、itoa、reverse、strindex和getop。

## 指针数组；指向指针的指针

## 多维数组

## 指针数组初始化

## 指针VS多维数组

## 命令行参数

## 指向函数的指针

## 复杂声明
