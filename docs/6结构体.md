# 结构体

结构体是一个或多个变量的集合，变量可以是不同类型，集合后赋予单独名字方便操作。特别是在大型程序里，结构体可将复杂的数据集合到一起，使这些数据作为一个单独单元操作。

一个使用结构体传统的例子是工资单记录：一条员工信息可包含名字、住址、身份证号、工资等多条信息。其中的一些信息本身也可以是结构体，如名字可分为姓和名。另一个例子就是描述图形：一个点由两个坐标组成，一个矩形由两个点组成。

结构体可复制，赋值，作为函数参数，以及作为函数返回值。同自动变量数组一样，作为自动变量的结构体也可初始化。

## 结构体基础

下面创建几个描述图形的结构体。图形基础是点，一个点由x和y坐标组成，且都为int型。对应的结构体声明为：

```c
struct point {
  int x;
  int y;
};
```

声明结构体使用关键字`struct`，声明内容放在大括号`{}`内，以分号`;`结尾。struct关键字后可跟/可不跟_结构标签_（如上面的point）。结构体标签可用于结构体数据定义简写， **标签实质就是替换大括号内的内容**。

结构体内部的变量称为_成员_。结构体成员、标签和普通变量可同名，上下文可区分。不同的结构体内成员可同名，不过最好在关系相当紧密的结构体内才使用相同的成员名。

结构体声明实质是定义一种类型。同普通变量一样，大括号后可跟一个或多个变量名。所以`strct {...}x, y, z;`同`int x, y, z`在形式上相同，即声明x、y和z变量并分配内存。

后面不跟变量的结构体声明不分配内存，仅描述了一个结构体模板。如果声明结构体的同时声明了标签，则此标签可用于结构体实例定义，如使用上面的point标签定义`struct point pt`。定义了pt是一个struct point结构体类型。

结构体定义后可立即初始化，各成员初始化值须为常量表达式，如`struct point maxpt = {320, 200};`。结构体自动变量可通过赋值，或返回相应结构体的函数的返回值初始化。

结构体成员通过点操作`.`符访问，如打印点pt的坐标`printf("(%d, %d)\n", pt.x, pt.y);`，或者计算该点到原点(0,0)间的距离：

```c
#include <math.h>
double dist;
dist = sqrt(pow((double)pt.x, 2) + pow((double)pt.y, 2));
```

结构体可嵌套。比如用两个点表示矩形的对角，以表示矩形：

```c
struct rect {
  struct point pt1;
  struct point pt2;
};
```

则可声明scree为矩形`struct rect screen`，同样利用点操作符访问到screen变量中pt1的x坐标`screen.pt1.x`。

## 结构体和函数

对结构体合法的操作只有：赋值或复制、使用`&`取地址和访问成员。赋值或复制包括作为函数参数，以及作为函数返回值。_结构体不可比较。_ 结构体可使用一列常量成员初始化；结构体自动变量还可通过赋值初始化。

下面定义一些操作点和矩形的函数来展示函数结构体操作。至少有3种方式实现函数操作结构体：单独传递成员，传递整个结构体，传递结构体指针。每种都有优缺点。

第一个函数为makepoint，结构两个int型作为参数，返回point结构体：

```c
struct point makepoint(int x, int y) {
  struct point tmp;
  tmp.x = x;
  tmp.y = y;
  return tmp;
}
```

上面参数名和结构体成员名并没有冲突，实际上使用相同名字可强调两者关系。

makepoint函数可用来动态初始化结构体，或为函数提供结构体参数：

```c
struct rect screen;
struct point middile;
struct point makepoint(int, int);
screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(3, 4);
middile = makepoint((screen.pt1.x + screen.pt2.x) / 2,
                    (screen.pt1.y + screen.pt2.y) / 2);
```

下面为一组进行point运算的函数，如：

```c
struct point addpoint(struct point p1, struct point p2) {
  p1.x += p2.x;
  p1.y += p2.y;
  return p1;
}
```

参数和返回值都是结构体。由于结构体类型也是值传递，所以没使用中间变量，而是使用了增加p1成员值的方法实现了point类型相加。

下一个例子是判断点是否在矩形内，可在左边线和下边线上，但不能在右边线和上边线上：

```c
int ptinrect(struct point p, struct rect r) {
  return p.x >= r.pt1.x && p.x < r.pt2.x &&
    p.y >= r.pt1.y && p.y < r.pt2.y;
}
```

不过此函数需pt1应在pt2左下方的基础上。下面这个例子就是返回一个矩形，保证pt1在pt2左下方：

```c
struct rect canonrect(struct rect r) {
  struct rect tmp;
  tmp.pt1.x = min(r.pt1.x, r.pt2.x);
  tmp.pt1.y = min(r.pt1.y, r.pt2.y);

  tmp.pt2.x = max(r.pt1.x, r.pt2.x);
  tmp.pt2.y = max(r.pt1.y, r.pt2.y);

  return tmp;
}
```

如需为函数传递大型结构体，使用指针比复制整个结构体更有效率。结构体指针定义与普通变量指针定义完全相同。如定义`struct point *pp`，就定义了pp是一个指向struct type类型的指针。同样，如果pp指向一个结构体，则`(*pp).x`和`(*pp).y`就是结构体成员。如：

```javascript
struct point origin, *pp;
pp = &origin;
origin = makepoint(10, 20);
printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
```

结构体指针使用相当频繁，所以C语言提供了通过结构体指针访问成员的简便方法：

```c
p->memeber-of-structure
```

所以也可写成：

```c
printf("origin is (%d,%d)\n", pp->x, pp->y);
```

`.`和`->`操作符的执行顺序都是从左到右，所以如果有声明`struct rect r, *rp = &r;`，则下面表达式都等价：

```c
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
```

**`.`、`->`、`()`和用于下标的`[]`操作符是优先级最高的操作符。** 所以，如果有声明：

```javascript
struct {
  int len;
  char *str;
} * p;
```

则`++p->len`为自增len，而非p，因为其实质为`++(p->len)`。可使用括号改变计算顺序，`(++p)->len`访问len属性前自增p，`(p++)->len`（括号可省）为访问len后自增p。

同样，`*p->str`为获取str所指内容，`*p->str++`为获取str所指内容后自增str（同`*s++`），`(*p->str)++`自增str所指内容，`*p++->str`为获取str所指内容后自增p。

## 结构体数组

## 结构体指针

## 引用自身的结构体

## 表查找

## 类型定义typedef

## 共用体（Union）

## 位字段（Bit Field）
