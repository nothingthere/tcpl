# 结构体

结构体是一个或多个变量的集合，变量可以是不同类型，集合后赋予单独名字方便操作。特别是在大型程序里，结构体可将复杂的数据集合到一起，使这些数据作为一个单独单元操作。

一个使用结构体传统的例子是工资单记录：一条员工信息可包含名字、住址、身份证号、工资等多条信息。其中的一些信息本身也可以是结构体，如名字可分为姓和名。另一个例子就是描述图形：一个点由两个坐标组成，一个矩形由两个点组成。

结构体可复制，赋值，作为函数参数，以及作为函数返回值。同自动变量数组一样，作为自动变量的结构体也可初始化。

## 结构体基础

下面创建几个描述图形的结构体。图形基础是点，一个点由x和y坐标组成，且都为int型。对应的结构体声明为：

```c
struct point {
  int x;
  int y;
};
```

声明结构体使用关键字`struct`，声明内容放在大括号`{}`内，以分号`;`结尾。struct关键字后可跟/可不跟_结构标签_（如上面的point）。结构体标签可用于结构体数据定义简写， **标签实质就是替换大括号内的内容**。

结构体内部的变量称为_成员_。结构体成员、标签和普通变量可同名，上下文可区分。不同的结构体内成员可同名，不过最好在关系相当紧密的结构体内才使用相同的成员名。

结构体声明实质是定义一种类型。同普通变量一样，大括号后可跟一个或多个变量名。所以`strct {...}x, y, z;`同`int x, y, z`在形式上相同，即声明x、y和z变量并分配内存。

后面不跟变量的结构体声明不分配内存，仅描述了一个结构体模板。如果声明结构体的同时声明了标签，则此标签可用于结构体实例定义，如使用上面的point标签定义`struct point pt`。定义了pt是一个struct point结构体类型。

结构体定义后可立即初始化，各成员初始化值须为常量表达式，如`struct point maxpt = {320, 200};`。结构体自动变量可通过赋值，或返回相应结构体的函数的返回值初始化。

结构体成员通过点操作`.`符访问，如打印点pt的坐标`printf("(%d, %d)\n", pt.x, pt.y);`，或者计算该点到原点(0,0)间的距离：

```c
#include <math.h>
double dist;
dist = sqrt(pow((double)pt.x, 2) + pow((double)pt.y, 2));
```

结构体可嵌套。比如用两个点表示矩形的对角，以表示矩形：

```c
struct rect {
  struct point pt1;
  struct point pt2;
};
```

则可声明scree为矩形`struct rect screen`，同样利用点操作符访问到screen变量中pt1的x坐标`screen.pt1.x`。

## 结构体和函数

对结构体合法的操作只有：赋值或复制、使用`&`取地址和访问成员。赋值或复制包括作为函数参数，以及作为函数返回值。_结构体不可比较。_ 结构体可使用一列常量成员初始化；结构体自动变量还可通过赋值初始化。

下面定义一些操作点和矩形的函数来展示函数结构体操作。至少有3种方式实现函数操作结构体：单独传递成员，传递整个结构体，传递结构体指针。每种都有优缺点。

第一个函数为makepoint，结构两个int型作为参数，返回point结构体：

```c
struct point makepoint(int x, int y) {
  struct point tmp;
  tmp.x = x;
  tmp.y = y;
  return tmp;
}
```

上面参数名和结构体成员名并没有冲突，实际上使用相同名字可强调两者关系。

makepoint函数可用来动态初始化结构体，或为函数提供结构体参数：

```c
struct rect screen;
struct point middile;
struct point makepoint(int, int);
screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(3, 4);
middile = makepoint((screen.pt1.x + screen.pt2.x) / 2,
                    (screen.pt1.y + screen.pt2.y) / 2);
```

下面为一组进行point运算的函数，如：

```c
struct point addpoint(struct point p1, struct point p2) {
  p1.x += p2.x;
  p1.y += p2.y;
  return p1;
}
```

参数和返回值都是结构体。由于结构体类型也是值传递，所以没使用中间变量，而是使用了增加p1成员值的方法实现了point类型相加。

下一个例子是判断点是否在矩形内，可在左边线和下边线上，但不能在右边线和上边线上：

```c
int ptinrect(struct point p, struct rect r) {
  return p.x >= r.pt1.x && p.x < r.pt2.x &&
    p.y >= r.pt1.y && p.y < r.pt2.y;
}
```

不过此函数需pt1应在pt2左下方的基础上。下面这个例子就是返回一个矩形，保证pt1在pt2左下方：

```c
struct rect canonrect(struct rect r) {
  struct rect tmp;
  tmp.pt1.x = min(r.pt1.x, r.pt2.x);
  tmp.pt1.y = min(r.pt1.y, r.pt2.y);

  tmp.pt2.x = max(r.pt1.x, r.pt2.x);
  tmp.pt2.y = max(r.pt1.y, r.pt2.y);

  return tmp;
}
```

如需为函数传递大型结构体，使用指针比复制整个结构体更有效率。结构体指针定义与普通变量指针定义完全相同。如定义`struct point *pp`，就定义了pp是一个指向struct type类型的指针。同样，如果pp指向一个结构体，则`(*pp).x`和`(*pp).y`就是结构体成员。如：

```javascript
struct point origin, *pp;
pp = &origin;
origin = makepoint(10, 20);
printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
```

结构体指针使用相当频繁，所以C语言提供了通过结构体指针访问成员的简便方法：

```c
p->memeber-of-structure
```

所以也可写成：

```c
printf("origin is (%d,%d)\n", pp->x, pp->y);
```

`.`和`->`操作符的执行顺序都是从左到右，所以如果有声明`struct rect r, *rp = &r;`，则下面表达式都等价：

```c
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
```

**`.`、`->`、`()`和用于下标的`[]`操作符是优先级最高的操作符。** 所以，如果有声明：

```javascript
struct {
  int len;
  char *str;
} * p;
```

则`++p->len`为自增len，而非p，因为其实质为`++(p->len)`。可使用括号改变计算顺序，`(++p)->len`访问len属性前自增p，`(p++)->len`（括号可省）为访问len后自增p。

同样，`*p->str`为获取str所指内容，`*p->str++`为获取str所指内容后自增str（同`*s++`），`(*p->str)++`自增str所指内容，`*p++->str`为获取str所指内容后自增p。

## 结构体数组

下面实现一个统计文本中C关键字的程序。需一个含字符串的数组，还需一个含对应字符串数量的整型数组。一种方法是使用同步数组，如：

```c
char *keyword[NKEYS];
int keycount[NEKEYS];
```

不过，如果是同步数组，最好使用结构体代替，每个关键字及其出现次数为一个结构体：

```javascript
struct key {
  char *word;
  int count;
} keytab[NKEYS];
```

声明了key结构体，并定义了keytab为此结构体类型数组，且分配了内存。也可写成：

```javascript
struct key {
  char *word;
  int count;
};

struct key keytab[NKEYS];
```

由于keytab所含关键字数量固定，所以可将其设置为外部变量，并在定义时初始化：

```javascript
struct key {
  char *word;
  int count;
} keytab[] = {{"auto", 0},    {"break", 0},    {"case", 0},
                     {"char", 0},    {"const", 0},    {"continue", 0},
                     {"default", 0}, {"int", 0},      {"unsigned", 0},
                     {"void", 0},    {"volatile", 0}, {"while", 0}};
```

与普通数组一样，数组元素个数会自动计算。

整个程序的执行过程为使用将定义的getword函数获取下一个单词，然后使用二叉树查找算法判断获取的单词是否存在于keytab内，这就要求初始化keytab时各结构体内关键字需按字母顺序递增排序。

```javascript
#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define MAXWORD 100

int main(int argc, char *argv[]) {
  int n;
  char word[MAXWORD];

  // 读取并计数
  while (getword(word, MAXWORD) != EOF) {
    if (isalpha(word[0]))
      if ((n = binsearch(word, keytab, NKEYS)) >= 0)
        keytab[n].count++;
    // printf("%s\n", word);
  }

  // 打印结果
  for (n = 0; n < NKEYS; n++)
    if (keytab[n].count > 0)
      printf("%4d %s\n", keytab[n].count, keytab[n].word);

  return 0;
}

int binsearch(char *word, struct key table[], int n) {
  int cond;
  int low, high, mid;
  low = 0;
  high = n - 1;
  while (low <= high) {
    mid = (low + high) / 2;
    if ((cond = strcmp(word, table[mid].word)) < 0)
      high = mid - 1;
    else if (cond > 0)
      low = mid + 1;
    else
      return mid;
  }
  return -1;
}
```

NKEYS是keytab中关键字/结构体的数量。可手动计算，不过最可靠的方法还是使用机器，如果keytab中的内容需改变尤需如此。

数组的长度在编译时才确定。数组长度为数组大小除以数组元素大小，所以确定数组长度的方法为：

```c
size of keytab / size of struct key
```

C中的一元操作符sizeof可用于计算所有对象的大小。表达式`sizeof object`和`sizeof (type name)`的返回值为表示对象和某个类型所占byte数的整型值。（严格地讲，sizeof返回的是一个unsigned整数，其类型为标准库stddef.h中定义的size_t类型。）。sizeof接受的类型可为int和double等基本类型，也可为通过结构体定义的类型，也可为指针。

此例中，数组长度为为数组大小除以一个元素的大小。此处在#define中计算NKEYS的值：

```c
#define NKEYS sizeof(keytab) / sizeof(struct key)
```

还有一种方法就是用数组大小除以一个特定元素大小。（_一般为第一个元素，测试了数组无元素的情况，居然能返回0_）。

```c
#define NKEYS sizeof(keytab) / sizeof(keytab[0])
```

sizeof不能用在#if后，因为与处理器不解析类型名。不过可用在#define后，因为预处理器不会计算#define语句。

下面的getword比此程序所需更具通用性？，不过也不复杂。getword函数读取下一个"单词"，此单词可以是由字母开始后跟字母或数字的字符串，可以是一个单独的非空字符。函数返回值是单词的首字母，或EOF，或字符本身。

```javascript
int getword(char *word, int lim) {
  int getch(void);
  void ungetch(int);
  // char *w = word;
  int c;
  while ((c = getch()) == ' ' || c == '\t')
    ;
  if (c != EOF) {
    *word++ = c;
  }
  if (!isalpha(c)) { /*可能返回EOF*/
    *word = '\0';
    return c;
  }
  for (; --lim > 0; word++) {
    if (!isalnum(*word = getch())) {
      ungetch(*word);
      break;
    }
  }

  *word = '\0';
  return word[0];
}
```

- [ex6-1](ex/6-1.c)：改进getword函数，使其支持下划线、字符串常量、注释和预处理行。

## 结构体指针

## 引用自身的结构体

## 表查找

## 类型定义typedef

## 共用体（Union）

## 位字段（Bit Field）
